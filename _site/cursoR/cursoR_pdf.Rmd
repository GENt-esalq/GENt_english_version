# Treinamento em Programação no Ambiente R

Esse material foi elaborado para o **Treinamento em Programação no Ambiente R**
organizado pelo GENt, grupo de Divulgação Científica do Programa de Pós-Graduação em Genética e Melhoramento de Plantas da ESALQ- USP. 

Você pode acessar mais informações sobre o grupo neste [link](https://gent-esalq.github.io/). No site você pode encontrar as atividades que temos desenvolvido. 

Este treinamento também recebe apoio do grupo [GVENCK](https://gvenck.github.io/1home.html) e do [Departamento de Genética da ESALQ](http://www.genetica.esalq.usp.br/).

Sugerimos que, antes de iniciar a prática aqui descrita, siga [este tutorial](https://GENt-esalq.github.io/cursoR/Tutorial_instalacao.html) para instalação do R e do RStudio.

# Familiarização com a interface do RStudio

Abrindo o RStudio você verá:

<img src="imagens/Rstudio.png"  style="width:700px;height:500px;">

A interface é separada em quatro janelas com principais funções:

* Edição de código
* Ambiente de trabalho e histórico
* Console
* Arquivos, gráficos, pacotes e ajuda

Explore cada uma das janelas. São inúmeras funcionalidades para cada uma delas, veremos algumas delas ao decorrer do curso.

## Um primeiro script

A janela de edição de código (provavelmente localizada no canto superior esquerdo) você irá utilizar para escrever o seu código. Abra um novo script clicando no `+` no canto superior esquerdo e selecionando `R script`.

Vamos então iniciar os trabalhos com o tradicional `Hello World`. Digite no seu script:

```{r}
cat("Hello world")
```

Agora, selecione a linha e aperte o botão `Run` ou utilize `Ctrl + enter`.

Ao fazer isso o seu código será processado na janela `Console`, onde aparecerá em azul (se você estiver com as cores padrão do R) o código escrito e, logo em seguida, o resultado desejado. A linha somente não será processada no console se houver o símbolo `#` na frente. Agora, experimente colocar `#` na frente do código escrito. E, novamente, selecione a linha e aperte `Run`. 

```{r}
# cat("Hello world")
```

O símbolo `#` é muito utilizado para realizar **comentários** ao decorrer do código. Esta é uma ótima prática para deixar o código organizado e para que você possa lembrar mais tarde o que você mesmo/a estava pensando quando o escreveu ou para que outras pessoas possam entendê-lo. Como no exemplo:

```{r}
# Iniciando os trabalhos no R
cat("Hello world")
```

**Importante**: sempre que quiser realizar alguma alteração, edite o seu script e não diretamente no console, pois tudo o que neste é escrito, não terá como ser salvo!

Para salvar seu script, você pode utilizar a aba `Files` localizada (como padrão) no canto direito inferior para procurar uma localização de sua preferência, criar uma nova pasta com o nome `CursoR`. 

<span style="color:red"> Dica: </span>

* Evite colocar espaços e pontuações no nome das pastas e arquivos, isso pode dificultar o acesso via linha de comando no R. Por exemplo, ao invés de `Curso R`, optamos por `CursoR`.

Depois, basta clicar no disquete localizado no cabeçalho do RStudio ou com `Ctrl + s` e selecionar o diretório `CursoR` criado. Scripts em R são salvos com a extensão `.R`. 

## Estabelecendo diretório de trabalho

Outra boa prática no R é deixar o script no mesmo diretório onde estão seus dados brutos (arquivos de entrada no script) e os dados processados (gráficos, tabelas, etc). Para isso, vamos fazer com que o R identifique o mesmo diretório em que você salvou o script como **diretório de trabalho**, assim ele entenderá que é dali que precisa obter os dados e para lá que também irão os resultados.

Você pode fazer isso utilizando as facilidades do RStudio, basta localizar o diretório `CursoR` pela aba `Files`, clique em `More` e depois "Set as Working Directory". Repare que irá aparecer no console algo como:

```{r, eval=FALSE}
setwd("~/Documents/CursoR")
```

Ou seja, você pode utilizar este mesmo comando para realizar esta ação. Esta então será nossa pasta de trabalho. Quando estiver perdido/a ou para ter certeza que o diretório de trabalho foi alterado utilize:

```{r, eval=FALSE}
getwd()
```

## Facilitando a vida com `Tab`

Agora, imagine que você tem um diretório como `~/Documentos/mestrado/semestre1/disciplina_tal/aula_tal/dados_28174/analise_276182/resultados_161/`. Não é fácil lembrar todo este caminho para escrever num comando `setwd()`.

Além da facilidade da janela do RStudio, você pode utilizar a tecla `Tab` para completar o caminho para você. Experimente buscando alguma pasta no seu computador. Basta começar a digitar o caminho e apertar `Tab`, ele irá completar o nome para você! Se você tiver mais do que um arquivo com aquele início de nome, aperte duas vezes o `Tab`, ele mostrará todas as opções.

O `Tab` funciona não só para indicar caminhos, mas também para comandos e nomes de objetos. É muito comum errarmos no código por erros de digitação, utilizar o `Tab` fará com que reduza significativamente esses erros.

# Operações básicas

Vamos então à linguagem! 

O R pode funcionar como uma simples **calculadora**, que utiliza a mesma sintaxe que outros programas (como o excel):

```{r, eval=FALSE}
#########################
# Script Treinamento R

# Data: 16/05/2019
# GENt
##########################

1+1.3                 #Decimal definido com "."
2*3
2^3
4/2

sqrt(4)              #raíz quadrada
log(100, base = 10)  #logarítmo na base 10
log(100)             #logarítmo com base neperiana

```

Agora, utilize as operações básicas para solucionar expressão abaixo. Lembre-se de utilizar parênteses `()` para estabelecer prioridades nas operações.

$(\frac{13+2+1.5}{3})+ log_{4}96$

Resultado esperado:

```{r, echo=FALSE}
((13+2+1.5)/3) + log(96, base = 4)
```

Os comandos `log` e `sqrt` são duas de muitas outras funções básicas que o R possui. Para todas elas o R possui uma descrição para auxiliar no seu uso, para acessar essa ajuda use:

```{r, eval=FALSE}
?log
```

E será aberta a descrição da função na janela `Help` do RStudio.

Se a descrição do próprio R não for suficiente para você entender como funciona a função, busque no google (de preferência em inglês). Existem diversos sites e fóruns com informações didáticas das funções do R.

## Operações com vetores

Os vetores são as estruturas mais simples trabalhadas no R. Construímos um vetor com uma sequencia numérica usando:

```{r}
c(1,3,2,5,2)
```

**MUITA ATENÇÃO**: O *c* é a função do R (*Combine Values into a Vector or List*) com a qual construímos um vetor! 

Utilizamos o simbolo `:` para criar sequencias de números inteiros, como:

```{r}
1:10
```

Podemos utilizar outras funções para gerar sequencias, como:

```{r}
seq(from=0, to=100, by=5)
# ou
seq(0,100,5) # Se você já souber a ordem dos argumentos da função

```

* Crie uma sequencia utilizando a função `seq` que varie de 4 a 30, com intervalos de 3 em 3.

```{r, echo=FALSE}
seq(from=4, to=30, by=3)
```

A função `rep` gera sequencias com números repetidos:

```{r}
rep(3:5, 2)
```

Podemos realizar operações utilizando esses vetores:

```{r,eval=FALSE}
c(1,4,3,2)*2
c(4,2,1,5)+c(5,2,6,1)
c(4,2,1,5)*c(5,2,6,1)
```

Repare que já esta ficando cansativo digitar os mesmos números repetidamente, vamos resolver isso criando **objetos** para armazenar nossos vetores e muito mais. 

# Criando objetos

O armazenamento de informações em objetos e a possível manipulação desses faz do R uma linguagem *orientada por objetos*. Para criar um objeto basta atribuir valores para as variáveis, como a seguir:

```{r, results='hide'}
x = c(30.1,30.4,40,30.2,30.6,40.1)
# ou
x <- c(30.1,30.4,40,30.2,30.6,40.1)

y = c(0.26,0.3,0.36,0.24,0.27,0.35)
```

Os mais antigos costumam usar o sinal `<-`, mas tem a mesma função de `=`. Escolha usar o qual preferir.

Para acessar os valores dentro do objeto basta:

```{r}
x
```

A linguagem é sensível à letras maiúsculas e minúsculas, portanto `x` é diferente de `X`:

```{r, eval=FALSE}
X
```

O objeto `X` não foi criado. 

Podemos então realizar as operações com o objeto criado:

```{r, results='hide'}
x*2
x + y
x*y
```

E podemos armazenar a operação em outro objeto:

```{r, results='hide'}
z <- (x+y)/2
z
```

Podemos também aplicar algumas funções, como exemplo:

```{r}
sum(z)  # soma dos valores de z
mean(z) # média 
var(z)  # variância
```

Acessamos somente o 3º valor do vetor criado com `[]`:

```{r, results='hide'}
z[3]
```

Também podemos acessar o número da posição 2 a 4 com:

```{r}
z[2:4]
```

Para obter informações do vetor criado utilize:

```{r}
str(z)
```

A função `str` nos diz sobre a estrutura do vetor, que se trata de um vetor **numérico** com 6 elementos. 

Os vetores também podem receber outras categorias como **caracteres**:

```{r}
clone <- c("GRA02", "URO01", "URO03", "GRA02", "GRA01", "URO01")
```

Outra classe são os **fatores**, esses podem ser um pouco complexos de lidar.

De forma geral, fatores são valores categorizados por `levels`, como exemplo, se transformarmos nosso vetor de caracteres `clone` em fator, serão atribuidos níveis para cada uma das palavras:

```{r}
clone_fator <- as.factor(clone)
str(clone_fator)
levels(clone_fator)
```

Dessa forma, teremos apenas 4 níveis para um vetor com 6 elementos, já que as palavras "GRA02" e "URO01" se repetem. Podemos obter o número de elementos do vetor ou o seu comprimento com:

```{r}
length(clone_fator)
```

Também há vetores **lógicos**, que recebem valores de verdadeiro ou falso:

```{r}
logico <- x > 40
logico   # Os elementos são maiores que 40?
```

Com ele podemos, por exemplo, identificar quais são as posições dos elementos maiores que 40:

```{r}
which(logico)  # Obtendo as posiçoes dos elementos TRUE

x[which(logico)] # Obtendo os números maiores que 40 do vetor x pela posição
```

Encontre mais sobre outros operadores lógicos, como o `>` utilizado, neste [link](http://www.statmethods.net/management/operators.html).

**Warning1**

Faça uma sequência numérica, contendo 10 valores inteiros, e salve em um objeto chamado "a".

```{r}
(a <- 1:10)
```

Crie outra sequência, utilizando números decimais e qualquer operação matemática, de tal forma que seus valores sejam idênticos ao objeto "a".

```{r}
b <- seq(from = 0.1, to = 1, 0.1)
(b <- b*10)
```

Os dois vetores parecem iguais, não?

Então, utilizando um operador lógico, vamos verificar o objeto "b" é igual ao objeto "a".

```{r}
a==b
```

Alguns valores não são iguais. Como isso é possivel?

```{r}
a==round(b)
```

**Warning2**

Não é possível misturar diferentes classes dentro de um mesmo vetor, ao tentar fazer isso repare que o R irá tentar igualar para uma única classe:

```{r}
errado <- c(TRUE, "vish", 1)
errado
```

No caso, todos os elementos foram transformados em caracter.

**Algumas Dicas**: 

* Cuidado com a prioridade das operações, na dúvida, sempre acrescente parenteses conforme seu interesse de prioridade.
* Lembre-se que, se esquecer de fechar algum `(` ou `[` ou `"`, o console do R ficará esperando você fechar indicando um `+`, nada será processado até que você digite diretamente no console um `)`.
* Cuidado para não sobrepor objetos já criados criando outros com o mesmo nome. Use, por exemplo: altura1, altura2.
* Mantenha no seu script .R somente os comandos que funcionaram e, de preferência, adicione comentários. Você pode, por exemplo, comentar dificuldades encontradas, para que você não cometa os mesmos erros mais tarde.

> Você já pode fazer os exercícios da [**Sessão 1**](exercicios.html#sessao1)

<span style="color:red"> Paramos aqui no primeiro dia. </span>

* Caso não tenha salvado os objetos criados até agora, obtenha-os [aqui](https://GENt-esalq.github.io/cursoR/dia1.RData).

* [Aqui](https://GENt-esalq.github.io/cursoR/dia1.R) você pode acessar um exemplo de script `.R` para esse primeiro dia.

* E [aqui](https://GENt-esalq.github.io/cursoR/dia1.Rmd) um exemplo de arquivo `.Rmd` para gerar um relatório com o conteúdo desse primeiro dia. E suas versões compiladas em [pdf](https://GENt-esalq.github.io/cursoR/dia1.pdf) e [html](https://GENt-esalq.github.io/cursoR/dia1.html).

## Matrizes

As matrizes são outra classe de objetos muito utilizadas no R, com elas podemos realizar operações de maior escala de forma automatizada.

Por serem usadas em operações, normalmente armazenamos nelas elementos numéricos. Para criar uma matriz, determinamos uma sequência de números e indicamos o número de linhas e colunas da matriz:

```{r}
X <- matrix(1:12, nrow = 6, ncol = 2)
X
```

Podemos também utilizar sequencias já armazenadas em vetores para gerar uma matriz, desde que eles sejam numéricos:

```{r}
W <- matrix(c(x,y), nrow = 6, ncol =2)
W
```

Com elas podemos realizar operações matriciais:

```{r}
X*2
X*X        
X%*%t(X)          # Multiplicação matricial
```

Utilizar essas operações exige conhecimento de álgebra de matrizes, se quiser se aprofundar a respeito, o livro *Linear Models in Statistics, Rencher (2008)* possui um boa revisão à respeito. Você também pode explorar a sintaxe do R para essas operações neste [link](http://www.statmethods.net/advstats/matrix.html).

Acessamos os números internos à matriz dando as coordenadas [linha,coluna], como no exemplo:

```{r}
W[4,2] # Número posicionado na linha 4 e coluna 2
```

As vezes pode ser informativo dar nomes às colunas e às linhas da matriz, fazemos isso com:

```{r}
colnames(W) <- c("altura", "diametro")
rownames(W) <- clone
W
```

Essas funções `colnames` e `rownames` também funcionam nos data.frames.

## Data.frames

Diferente das matrizes, não realizamos operações com os data.frames, mas eles permitem a união de vetores com classes diferentes. Os *data frames* são semelhantes a tabelas geradas em outros programas, como o excel.

Os *data frames* são combinações de vetores de mesmo comprimento. Todos os que criamos até agora tem tamanho 6, verifique. 

Podemos assim combiná-los em colunas de um único data.frame:

```{r}
campo1 <- data.frame("clone" = clone,     # Antes do sinal de "="  
                     "altura" = x,        # estabelecemos os nomes  
                     "diametro" = y,      # das colunas
                     "idade" = rep(3:5, 2),
                     "corte"= logico) 
campo1
```

Podemos acessar cada uma das colunas com:

```{r}
campo1$idade
```

Ou também com:

```{r}
campo1[,4] 
```

Aqui, o número dentro dos colchetes se refere à coluna, por ser o segundo elemento (separado por vírgula). O primeiro elemento se refere à linha. Como deixamos o primeiro elemento vazio, estaremos nos referindo a todas as linhas para aquela coluna.

Dessa forma, se quisermos obter um conteúdo específico podemos dar as coordenadas com [linha,coluna]:

```{r}
campo1[1,2] 
```

* Obtenha o diâmetro do clone "URO03.

```{r, echo=FALSE}
campo1[3,3] 
```

Mesmo se tratando de um *data frame*, podemos realizar operações com os vetores numéricos que a compõe.

* Com o diâmetro e a altura das árvores, calcule o volume conforme a fórmula a seguir e armazene em um objeto `volume`:

$3.14*(diametro/2)^2*altura$

```{r, echo=FALSE}
volume <- 3.14*((campo1$diametro/2)^2)*campo1$altura
volume
```

Agora, vamos adicionar o vetor calculado com o volume ao nosso data.frame. Para isso use a função `cbind`.

```{r}
campo1 <- cbind(campo1, volume)
str(campo1)
```

**Algumas dicas**:

* Lembre-se que, para construir matrizes e *data frames*, o número de elementos em cada coluna tem que ser iguais.
* Caso não saiba o operador ou a função que deve ser utilizada, como o desvio padrão, busque no google algo como "desvio padrão R", ou melhor "standard deviation R". Logo nas primeiras páginas você obterá respostas. A comunidade do R é bastante ativa e grande parte das suas perguntas sobre ele já foram respondidas em algum lugar da web.
* Não esqueça que tudo o que fizer no R precisa ser explicitamente indicado, como uma multiplicação 4ac com `4*a*c`. Para gerar um vetor 1,3,2,6 é necessário: `c(1,3,2,6)`.

## Listas

Listas consistem em uma coleção de objetos, não necessariamente de mesma classe. Nelas podemos armazenar todos os outros objetos ja vistos e recuperá-los pela indexação com `[[`. Como exemplo, vamos utilizar alguns objetos que já foram gerados.

```{r}
minha_lista <- list(campo1 = campo1, media_alt = tapply(campo1$altura, campo1$idade, mean), matrix_ex = W)
str(minha_lista)
```

Quero acessar o data.frame `campo1`

```{r}
minha_lista[[1]]
# ou
minha_lista$campo1
```

Listas são muito úteis, por exemplo, quando vamos utilizar/gerar diversos objetos diferentes dentro de um loop. 

## Arrays

Este é um tipo de objeto que você provavelmente não irá utilizar agora no início, mas é bom saber da sua existência. São utilizados para armazenar dados com mais de duas dimensões. Por exemplo, se criarmos um array:

```{r}
(meu_array <- array(1:24, dim = c(2,3,4)))
```

Teremos quatro matrizes com duas linhas e três colunas e os números de 1 a 24 estarão distribuídos nelas por colunas.

> Agora você já pode fazer os exercícios da [**Sessão 2**](exercicios.html)

# Exportando e importando dados

Os objetos criados dentro do R podem ser exportados em arquivos de diversos formatos. Lembre-se que, se não definir todo o caminho que deseja depositar o arquivo, ele irá ser salvo no seu diretório de trabalho.

Para exportar o objeto no formato .RData:

```{r, eval=FALSE}
save(campo1, file = "campo1.RData")
```

Essa é uma forma de salvar o objeto trabalhado, se removermos ele com:

```{r, eval=FALSE}
rm(campo1)  # Certifique-se que salvou o objeto antes de removê-lo
```

Podemos facilmente obtê-lo novamente com:

```{r, eval=FALSE}
load("campo1.RData")
```

Para salvar todos os objetos do seu *workspace* use:

```{r, eval=FALSE}
save.image()
```

O R irá criar um arquivo `.Rdata` contendo todos os seus objetos.

Podemos exportar nossos objetos em outros formatos, como, por exemplo, `.txt` ou `.csv`. Para isso utilizamos:

```{r, eval=FALSE}
write.table(campo1, file = "campo1.txt", sep = ";", dec = ".", row.names = FALSE)
write.csv(campo1, file = "campo1.csv", row.names = TRUE)
```

Obs: Você pode adquirir pacotes para exportar e importar dados com outros fomatos, como exemplo o pacote `xlsx` exporta e importa dados com formato do excel.

Ao exportar, há diversas opções para a formatação do arquivo, é importante considerá-las se o arquivo for ser trabalhado em outro sofware posteriormente.

Abra os arquivos gerados para visualizar sua formatação.

Esses arquivos podem ser lidos novamente pelo R, utilizando as funções e suas especificações:

```{r, eval=FALSE}
campo1_txt <- read.table(file = "campo1.txt", sep=";", dec=".", header = TRUE)
campo1_csv <- read.csv(file = "campo1.csv")
head(campo1_txt)
head(campo1_csv)
```

Agora que aprendemos a importar dados, vamos trabalhar com o conjunto gerado a partir do formulário que vocês preencheram.

<span style="color:red">
A planilha com os dados será disponibilizada, adicione-a ao seu diretório de trabalho ou indique o caminho da pasta ao importá-la para dentro do R, como a seguir. Caso esteja difícil encontrá-la, acesse:</span> 

* [dados.RData](https://GENt-esalq.github.io/cursoR/dados_alunos.RData) 
* [dados.csv](https://GENt-esalq.github.io/cursoR/dados_alunos.csv)


Aqui usaremos o argumento `stringAsFactors` que impede que o R transforme os vetores da tabela em fatores, os quais são mais difíceis de trabalhar. O argumento `na.strings` irá indicar como foram nomeados os dados perdidos.

```{r, eval=FALSE}
dados <- read.csv(file = "dados_alunos.csv", stringsAsFactors = FALSE, na.strings="-")
```

```{r}
load("dados_alunos.RData")
```

Vamos explorar a estrutura dos dados coletados:

```{r}
str(dados)
# também
dim(dados)
```

Repare que nos nomes das colunas ainda estão as perguntas completas feitas no formulário, vamos alterar para nomes mais fáceis de trabalhar:

```{r}
colnames(dados) <- c("Data_pesq", "Idade", "Niver", "Genero", "Cidade", 
                     "Altura","Peso", "Area", "ConhecimentoR", "Outras_linguagens", 
                     "Utilizacao", "Motivacao")
str(dados)
```

# Paradoxo do aniversário

Nossa primeira análise com esses dados envolverá um problema denominado ["Paradoxo do aniversário"](https://en.wikipedia.org/wiki/Birthday_problem), que afirma que em um grupo de 23 pessoas (ou mais), escolhidas aleatoriamente, há mais de 50% de chance de duas pessoas terem a mesma data de aniversário.

Primeiro, vamos verificar em quantos somos, contando o número de linhas, para isso use a função `nrow`.

```{r}
nrow(dados)
```

Vamos então verificar se temos no nosso grupo pessoas que compartilham o mesmo dia de aniversário.

Podemos verificar isso facilmente com a função `table`, que indica a frequência de cada observação:
 
```{r, eval=FALSE}
table(dados$Niver)
```

# Estruturas condicionais

## if e else

Para nossa próxima atividade com os dados, vamos primeiro entender como funcionam as estruturas `if` e `else`.

Nas funções condicionais `if` e `else`, estabelecemos uma condição para if, se ela for verdade a atividade será realizada, caso contrário (else) outra tarefa será. Como no exemplo:

```{r}
if(2 >3){
  print("dois é maior que três")
} else {
  print("dois não é maior que três")
}
```

* Teste o nível de conhecimento em R obtidos no formulaŕio (9ª coluna) pela terceira pessoa que o respondeu (linha 3). Envie uma mensagem motivacional se ela não possuir qualquer conhecimento (nota 0), outra se possuir algum conhecimento (restante das notas). (dica: o sinal `==` se refere a "exatamente igual a")

```{r}
if(dados[3,9] == 0){
  print("Nunca é tarde para começar!")
} else {
  print("Já pegou o embalo, agora é só continuar!")
}
```

Podemos espeficiar mais do que uma condição repetindo a estrutura `if` `else`:

```{r}
if(dados[7,9] == 0){
  print("Nunca é tarde para começar!")
} else if (dados[7,9] > 0 && dados[7,9] < 5){
  print("Já pegou o embalo, agora é só continuar!")
} else {
  print("Nos avise se estivermos falando algo errado...hehe")
}
```

## Switch

Uma outra estrutura que também pode ser usada com o mesmo propósito é o `switch`. Esta estrutura é mais utilizada quando trabalhado com caracteres. Por isso vamos aplicá-la para explorar a área (8ª coluna) com que a quinta pessoa se identifica.

```{r}
switch(dados[5,8],
  Exatas = print("Será que aprendeu alguma linhagem de programação na graduação?"),
  Interdiciplinar = print("Em que foi a gradução?"),
  print("Ta aqui colocando o pezinho na exatas")
)

```

A estrutura `switch` costuma ser mais rápida que o `if` e `else`. Quando lidamos com grande quantidade de dados isso pode ser uma grande vantagem.

Mas repare que só é possível utilizar essas estruturas para um elemento individual do vetor, se quisermos percorrer o vetor inteiro precisamos recorrer a outro recurso.

# Estruturas de repetição

## For

Esse recurso pode ser a função `for`, uma função muito utilizada e poderosa. Ela constitui uma estrutura de loop, pois irá aplicar a mesma atividade repetidamente até atingir uma determinada condição. Veja exemplos:

```{r}
for(i in 1:10){
  print(i)
}

test <- vector()
for(i in 1:10){
  test[i] <- i+4 
}
test
```

Nos casos acima, `i` funciona como um index que irá variar de 1 até 10 a operação determinada entre chaves.

Com essa estrutura, podemos repetir a operação realizada com as estruturas `if` e `else` para todo o vetor:

```{r}
for(i in 1:nrow(dados)){
  if(dados[i,9] == 0){
    print("Nunca é tarde para começar!")
  } else if (dados[i,9] > 0 && dados[i,9] < 5){
    print("Já pegou o embalo, agora é só continuar!")
  } else {
      print("Nos avise se estivermos falando algo errado...hehe")
    }
}
```

**Dica: Identação**

Repare a diferença:

```{r, eval=FALSE}
# Sem identação
for(i in 1:nrow(dados)){
if(dados[i,9] == 0){
print("Nunca é tarde para começar!")
} else if (dados[i,9] > 0 && dados[i,9] < 5){
print("Já pegou o embalo, agora é só continuar!")
} else {
print("Nos avise se estivermos falando algo errado...hehe")
}
}

# Com identação correta
for(i in 1:nrow(dados)){
  if(dados[i,9] == 0){
    print("Nunca é tarde para começar!")
  } else if (dados[i,9] > 0 && dados[i,9] < 5){
    print("Já pegou o embalo, agora é só continuar!")
  } else {
    print("Nos avise se estivermos falando algo errado...hehe")
  }
}

```

Agora vamos trabalhar com a coluna 5, que possui a informação da cidade de origem dos participantes. Repare que alguns não colocaram o estado, como o exemplo sugeria. Vamos utilizar um loop para descobrir quais estão faltando. Vamos utilizar a função `grepl` para identificar as strings que contém o caracter "-", aqueles que tiverem consideraremos correto, os que não tiverem, vamos pedir para adicionar mais informações.

```{r}
# Exemplo do uso da função grepl
grepl("-", dados[1,5]) # A primeira linha contem o caracter "-"

for(i in 1:nrow(dados)){
  if(grepl("-", dados[i,5])){
    cat("Esse/a seguiu o exemplo direitinho. Parabéns!\n")
  } else {
    cat("Precisamos adicionar mais informações na linha", i, "\n")
  }
}
```

Para que seja possível imprimir conteúdo de objetos durante o loop, usamos a função `cat`, ela não separa cada resposta em uma linha, precisamos colocar o `\n` indicando a quebra de linha.

Agora vamos nos mesmos corrigir essas informações. Podemos armazenar uma variável a posição das linhas incorretas, então corrigiremos manualmente somente essas:

```{r}
corrigir <- vector()
for(i in 1:nrow(dados)){
  if(grepl("-", dados[i,5])){
    cat("Esse/a seguiu o exemplo direitinho. Parabéns!\n")
  } else {
    cat("Precisamos adicionar mais informações na linha", i, "\n")
    corrigir <- c(corrigir, i)
  }
}

```


<span style="color:red"> Paramos aqui na parte da manhã do segundo dia do treinamento.</span>

* Caso não tenha salvado os objetos criados até agora, obtenha-os [aqui](https://GENt-esalq.github.io/cursoR/dia2.1.RData).

* [Aqui](https://GENt-esalq.github.io/cursoR/dia2.1.R) você pode acessar um exemplo de script `.R`.

* E [aqui](https://GENt-esalq.github.io/cursoR/dia2.1.Rmd) um exemplo de arquivo `.Rmd` para gerar um relatório com o conteúdo até agora. E suas versões compiladas em [pdf](https://GENt-esalq.github.io/cursoR/dia2.1.pdf) e [html](https://GENt-esalq.github.io/cursoR/dia2.1.html).

> Como você faria para corrigir esses elementos errados? Tente!

Dica: [Primeiro busque quais são as cidades desses elementos (dados[corrigir,5]), depois, faça um novo vetor com os nomes corretos e substitua na tabela]{.spoiler}

Uma possibilidade de resposta:

```{r}
dados[corrigir,5]
novo <- c("São José dos Campos - SP", "Piracicaba - SP", "São Paulo - SP", "Piracicaba-SP",
          "Uberlância-MG", "Piracicaba-SP", "Uberaba-MG", "São Luis-MA", "Piracicaba-SP",
          "Piracicaba-SP")
dados[corrigir,5] <- novo

# Verificando se corrigiu
dados[,5]
```


> A coluna 2 da tabela se refere à idade dos participantes, imprima na tela (usando print ou cat) a década em que cada um nasceu, como a seguir: "Nasceu na década de 80".

Dica: [Faça um novo vetor com a subtração das idades pelo ano atual e depois faça um loop com uma condicional para imprimir as mensagens na tela]{.spoiler}

Uma possibilidade de resposta:

```{r}
decada <- 2019 - dados$Idade

for(i in 1:length(decada)){
  if(decada[i] > 1960 && decada[i] < 1970){
    print("Nasceu na década de 60")
  } else if(decada[i] >= 1970 && decada[i] < 1980){
    print("Nasceu na década de 70")
  } else if(decada[i] >= 1980 && decada[i] < 1990){
    print("Nasceu na década de 80")
  } else if(decada[i] >= 1990 && decada[i] < 2000){
    print("Nasceu na década de 90")
  } else {
    print("Xóvem")
  }
}
```


## While

Nesse tipo de estrutura de repetição a tarefa será realizada até que seja atingida determinada condição.

```{r}
x <- 1

while(x < 5){
  x <- x + 1
  print(x)
}
```

É muito importante que nessa estrutura a condição seja atingida, caso contrário o loop irá funcionar infinitamente e você terá que interrompê-lo por meios externos, como, se este utilizando RStudio, clicar no simbolo em vermelho no canto direito superior da janela do console, ou apertar Ctrl+C no console.

Não é muito difícil disso acontecer, basta um pequeno erro como:

```{r, eval=FALSE}
x <- 1

while(x < 5){
  x + 1
  print(x)
}
```

Aqui podemos utilizar os comandos `break` e `next` para atender a outras condições, como:

```{r}
x <- 1

while(x < 5){
  x <- x + 1
  if(x==4) break
  print(x)
}

x <- 1

while(x < 5){
  x <- x + 1
  if(x==4) next
  print(x)
}

```

## Repeat

Esta estrutura também exige uma condição de parada, mas esta condição é necessariamente colocada dentro do bloco de código com o uso do `break`. Ela então repete o bloco de código até a condição o interrompa.

```{r}
x <- 1
repeat{
  x <- x+1
  print(x)
  if(x==4) break
}

```

## Loops dentro de loops

É possível também utilizarmos estruturas de repetição dentro de estruturas de repetição. Por exemplo, se quisermos trabalhar tanto nas colunas como nas linhas de uma matrix.

```{r}
# Criando uma matrix vazia
ex_mat <- matrix(nrow=10, ncol=10)

# cada número dentro da matrix será o produto no índice da coluna pelo índice da linha
for(i in 1:dim(ex_mat)[1]) {
  for(j in 1:dim(ex_mat)[2]) {
    ex_mat[i,j] = i*j
  }
}

```

Fizemos um vídeo com mais detalhes sobre loops no R, aumentem nossa quantidade de views e likes por [lá](https://www.youtube.com/watch?v=VYOo7I5htOw).

> Faça os exercícios da [**Sessão 3**](exercicios.html)


**Algumas dicas**:

* Cuidado ao rodar o mesmo comando mais de uma vez, algumas variáveis podem não ser mais como eram antes. Para que o comando funcione da mesma forma é necessário que os objetos de entrada estejam da forma como você espera.
* Lembrem-se que `=` é para definir objetos e `==` é o sinal de igualdade. 
* Nas estruturas condicionais e de repetição, lembrem-se que é necessário manter a sintaxe esperada: If(){} e for(i in 1:10){}. No *for*, podemos trocar a letra que será o índice, mas é sempre necessário fornecer uma sequência de inteiros contínua.
* Usar identação ajuda a visualizar o começo e fim de cada estrutura de código e facilita o abrir e fechar de chaves. Identação são aqueles espaços que usamos antes da linha, como:

```{r}
# Criando uma matrix vazia
ex_mat <- matrix(nrow=10, ncol=10)

# cada número dentro da matrix será o produto no índice da coluna pelo índice da linha
for(i in 1:dim(ex_mat)[1]) {   # Primeiro nível, não tem espaço
  for(j in 1:dim(ex_mat)[2]) { # Segundo nível tem um espaço (tab)
    ex_mat[i,j] = i*j          # Terceiro nível tem dois espaços
  }                            # Fechei o segundo nível
}                              # Fechei o primeiro nível

```


# Elaboração de funções

Normalmente é uma boa prática criar um bloco de código se vai realizar aquela ação poucas vezes. Se for realizar várias vezes a ação e de uma vez só, vale a pena fazer um loop. Mas, se for realizar diversas vezes e o objeto de entrada for modificado vale a pena fazer uma função. E, na hierarquia, quando tiver acumulado muitas funções para realizar uma tarefa mais complexa, vale a pena construir um pacote.

Aqui não vamos nos aprofundar muito nesse assunto, talvez ele renda um outro módulo inteiro, vamos apenas passar noções básicas.

A função também é considerada um objeto no R, portanto você a atribui a uma variável, nesse caso à `quadra`. Então estabelecemos os argumentos da função, nesse caso `x`. Entre as chaves fica todo o corpo da função. Se você quer que a função retorne algum valor, é necessário utilizar o `return`.

```{r}
quadra <- function(x){
  z <- x*x
  return(z)
}

quadra(3)
quadra(4)

qualquer_nome <- 4
quadra(qualquer_nome)
```

Vamos complicar um pouco e também dar mais sentido para construir uma função. Vamos definir no seu corpo várias ações antes de retornar o valor, algo que não poderia ser feito usando uma única função já pronta do R.

```{r}
## Calcula o índice de massa corporal (IMC) dos participantes
IMC <- dados$Peso/quadra(dados$Altura)

## Calcula a média das idade dos participantes
id_med <- mean(dados$Idade)

## Calcula a mediana das idades dos participantes
id_median <- median(dados$Idade)

## Calcula a porgentagem de mulheres entre os participantes
mul <- 100*(length(which(dados$Genero == "Feminino"))/length(dados$Genero))

## Faz uma lista com todos os resultados
final_list <- list(IMC=IMC, idade_media = id_med, 
                   idade_mediana = id_median, porcentagem_mulheres = mul)
```

Para montarmos a função primeiro pensamos qual será o argumento de entrada, nesse caso, nosso arquivo de dados, um *data frame* contendo pelo menos as colunas `Peso`, `Altura`, `Idade` e `Genero`.

```{r}
minha_funcao <- function(df.entrada){
  ## Calcula o índice de massa corporal (IMC) dos participantes
  IMC <- df.entrada$Peso/quadra(df.entrada$Altura)
  
  ## Calcula a média das idade dos participantes
  id_med <- mean(df.entrada$Idade)
  
  ## Calcula a mediana das idades dos participantes
  id_median <- median(df.entrada$Idade)
  
  ## Calcula a porgentagem de mulheres entre os participantes
  mul <- 100*(length(which(df.entrada$Genero == "Feminino"))/length(df.entrada$Genero))
  
  ## Faz uma lista com todos os resultados
  final_list <- list(IMC=IMC, idade_media = id_med, 
                     idade_mediana = id_median, porcentagem_mulheres = mul)
  return(final_list)

}

test_list <- minha_funcao(df.entrada = dados)
test_list
```

Se é uma função para uso próprio, você saberá como deve ser o objeto de entrada, mas se ela for utilizada por outras pessoas, será necessário, além de uma prévia explicação de suas ações, verificar se o objeto de entrada esta de acordo com o esperado pela função.

```{r}

minha_funcao <- function(df.entrada){
  
  if (length(grep("Altura", colnames(df.entrada))) == 0 ||
      length(grep("Peso", colnames(df.entrada))) == 0 ||
      length(grep("Idade", colnames(df.entrada))) == 0 ||
      length(grep("Genero", colnames(df.entrada))) == 0)
    stop("Esta faltando alguma das informações.")
    

  ## Calcula o índice de massa corporal (IMC) dos participantes
  IMC <- df.entrada$Peso/quadra(df.entrada$Altura)
  
  ## Calcula a média das idade dos participantes
  id_med <- mean(df.entrada$Idade)
  
  ## Calcula a mediana das idades dos participantes
  id_median <- median(df.entrada$Idade)
  
  ## Calcula a porgentagem de mulheres entre os participantes
  mul <- 100*(length(which(df.entrada$Genero == "Feminino"))/length(df.entrada$Genero))
  
  ## Faz uma lista com todos os resultados
  final_list <- list(IMC=IMC, idade_media = id_med, 
                     idade_mediana = id_median, porcentagem_mulheres = mul)
  return(final_list)

}

test_list <- minha_funcao(df.entrada = dados)
```

```{r, eval= FALSE}
dados1 <- dados[,-2] # Removendo coluna de idade

test_list <- minha_funcao(df.entrada = dados1)

```

Para saber mais sobre desenvolvimento de funções acesse [aqui](https://www.r-bloggers.com/how-to-write-and-debug-an-r-function/) e, um pouco mais avançado, [aqui](http://adv-r.had.co.nz/Functions.html).

<span style="color:red"> Paramos aqui na parte da tarde do segundo dia do treinamento.</span>

* Caso não tenha salvado os objetos criados até agora, obtenha-os [aqui](https://GENt-esalq.github.io/cursoR/dia2.2.RData).

* [Aqui](https://GENt-esalq.github.io/cursoR/dia2.2.R) você pode acessar um exemplo de script `.R`.

* E [aqui](https://GENt-esalq.github.io/cursoR/dia2.2.Rmd) um exemplo de arquivo `.Rmd` para gerar um relatório com o conteúdo até agora. E suas versões compiladas em [pdf](https://GENt-esalq.github.io/cursoR/dia2.2.pdf) e [html](https://GENt-esalq.github.io/cursoR/dia2.2.html).

# Rodando outros scripts .R 

As vezes, parte do seu código demanda que você chame algo que foi rodado em outro script. Muitas pessoas também tem o costume de salvar as funções próprias em um script separado. Vamos fazer isso? 

* Abra um novo script .R, copie suas funções para ele e o salve como `funcoes.R`

Agora, você pode acessa-las usando:

```{r, eval=FALSE}
source("funcoes.R")
```

> Faça os exercícios da [**Sessão 4**](exercicios.html)


# Elaboração de gráficos simples

Para outros dados coletados, vamos gerar alguns gráficos simples utilizando as funções básicas do R. Existem pacotes como o `ggplot2`, `plotly` e `shiny` que possuem ferramentas muito poderosas para construção de gráficos, mas exigem um pouco mais de tempo para aprendizagem de sua sintaxe.

Os tipos mais comuns já possuem funções próprias, mas outros gráficos podem ser customizados de acordo com a necessidade do usuário. Vamos iniciar com um simples gráfico de frequências (ou histograma) para os dados de `Altura`.

```{r, eval=FALSE}
hist(dados$Altura)
```

Vamos adicionar alguns argumentos para dar uma personalizada:

* `breaks` para definir os intervalos para cada barra; 

```{r, eval=FALSE}
#### Histograma ####
#Utiliza um vetor de valores para obter as frequências
hist(dados$Altura)
hist(dados$Altura, breaks = 2)
hist(dados$Altura, breaks = 15) 

```

Agora tente fazer o **histograma para o peso**, aproveite para tentar alterar alguns parâmetros. Em seguida, serão apresentados outros gráficos que poderão ser utilizados.

```{r}
#### Bar plot ####
#É um gráfico interessante quando possuímos resultados da função table
gen <- table(dados$Genero)
barplot(gen)

```
```{r eval=FALSE}
#Alterando o eixo
barplot(gen, horiz = TRUE)

#Mais informações podem ser combinadas
nota_gen <- table(dados$ConhecimentoR, dados$Genero)
barplot(nota_gen)

```

Busque uma maneira de colocar a nota do R no eixo x e o gênero nas cores.

```{r echo=FALSE}
nota_gen <- table(dados$ConhecimentoR, dados$Genero)
barplot(t(nota_gen))
```

```{r eval=FALSE}
#### Pizza!!! ####
#Requer um vetor de contagens e os rótulos associados
pie(gen, names(gen))

#Tente criar o gráfico de pizza com a nota do R

```

```{r eval=FALSE}
#### Dot plots ####
#Utilizaremos um vetor de valores e um vetor de rótulos
dotchart(dados$Altura, labels = dados$Cidade)
#Também é possível criar grupos
dotchart(dados$Altura, labels = dados$Cidade, groups = as.factor(dados$Genero))

#Podemos criar uma coluna no data frame onde delimitaremos uma cor para cada uma das áreas:
dados$color[dados$Area=="Exatas"] <- "darkblue"
dados$color[dados$Area=="Biologicas"] <- "darkgreen"
dados$color[dados$Area=="Humanas"] <- "orange"
dados$color[dados$Area=="Interdiciplinar"] <- "red"
dados$color[dados$Area=="Agrarias"] <- "black"
dotchart(dados$Altura, labels = dados$Cidade, groups = as.factor(dados$Area), color = dados$color)

#Crie um objeto que corresponda ao data.frame 'dados' ordenado de acordo com a Altura (ou peso, como desejar!)
#Em seguida, tente criar o dot plot.

#### Curve ####
#Utiliza uma expressão/função 
curve(x^2 + 3*x)
curve(2*x, add = TRUE, col="red")

#### Boxplot ####
#Necessita de um vetor de valores ou uma expressão
boxplot(dados$Altura)
boxplot(dados$Altura~dados$Genero)

#Explore o bloxplot de outros atributos, podendo combiná-los
#Desafio: faça o boxplot da altura pela combinação dos grupos Genero e Area
boxplot(Altura~Genero*Area, data = dados)

#### Scatter plot ####
#Utilizaremos coordenadas de pontos.
plot(x = dados$Peso, y= dados$Altura)

```

## Parâmetros gráficos

É possível customizar os gráficos alterando seus eixos, cores, fontes, etc. Começaremos através do histograma:

* `col` para adicionar cor;
* `xlab` alterar título do eixo x;
* `ylab` alterar título do eixo y;
* `main` alterar título geral;

```{r, eval=FALSE}
hist(dados$Idade, breaks=6, col="blue", xlab="Idades", 
     ylab="Frequencia", main="Histograma das Idades (Curso 2019)")
```

Se preferir, podemos usar um gráfico de densidades de Kernel como:

```{r, eval=FALSE}
d <- density(dados$Idade, na.rm = TRUE)

plot(d, col="blue", xlab="Idades",
     ylab="Densidade", main="Densidade das Idades")
```

Vamos explorar um pouco mais o gráfico de pontos. Sabe- se que existe uma correlação entre o peso e a altura das pessoas, e que, a distribuição dessas características configura uma bimodal se não considerarmos os gênero dos indivíduos avaliados. Vamos avaliar a correlação entre essas caraterísticas com:

```{r}
#Busque explorar mais parâmetros no gráfico a seguir:
##Dica: tente alterar o nome dos eixos
plot(x = dados$Peso, y= dados$Altura)

#Linha de ajuste
abline(lm(Altura ~ Peso, data = dados), col="red")

#Verificar a correlação:
cor(dados$Altura, dados$Peso)
```

Alguns argumentos são específicos para cada função, busque mais informações sobre cada uma delas para entender sobre seus argumentos. Outros parâmetros gráficos mais recorrentes são os relacionados com:

* O tamanho de texto e símbolos, chamados de `cex`; 
* Os símbolos de plotagem (25 ao todo), através do parâmetro `pch`;
* Há os relacionados com a fonte (`font` e `family`);
* Cores (`col`, `bg`, `fg`);

```{r eval=FALSE}
#Tamanho, pontos e cores
plot(x = dados$Peso, y= dados$Altura, 
     main = "Peso  x Altura", #Título principal 
     xlab = "Peso", #Eixo x
     ylab = "Altura", #Eixo y
     cex=2,
     cex.axis=1.5)

#Agora, busque alterar o nome dos rótulos (lab) e do título (main)
#Utilize o parâmetro 'pch=' e coloque um número de 0 a 25
#De maneira similar ao tamanho, trabalhe com as cores (utilize o color() para ver todas as cores disponíveis) 

# Fontes e linhas #
plot(x = dados$Peso, y= dados$Altura, 
     main = "Peso  x Altura", #Título principal 
     xlab = "Peso", #Eixo x
     ylab = "Altura", #Eixo y
     font=3,
     family="serif", #Fonte do seu computador (Windows: "TT Courier New")
     )
abline(lm(Altura ~ Peso, data = dados), col="red", lty=3)


#Incrementando:
plot(x = dados$Peso, y= dados$Altura, 
     main = "Peso  x Altura", #Título principal 
     xlab = "Peso", #Eixo x
     ylab = "Altura", #Eixo y
     col = as.factor(dados$Genero)
     )

#Nesse mesmo gráfico, procure mudar a forma dos pontos de acordo com a nota do R.

#### Legenda ####
plot(x = dados$Peso, y= dados$Altura, 
     main = "Peso  x Altura", #Título principal 
     xlab = "Peso", #Eixo x
     ylab = "Altura", #Eixo y
     col = as.factor(dados$Genero),
     pch=10)

legend("bottomright", legend = c("Feminino", "Masculino"), col=1:2, pch=10)
```

 Obtidos todos esses gráficos, pode ser bom para visualização tê-los lado a lado.
 
```{r, eval=FALSE}
 #### Mais de um gráfico? Claro! ####
par(mfrow=c(1,2))
hist(dados$Altura)
hist(dados$Peso)

#Lembrar:
par(mfrow=c(1,1))
```

## Desafio!!!

Busque resolver o desafio sem observar a resposta. Vocês conseguirão avançar muito, um ou outro detalhe pode acabar sendo mais difícil. Nesse ponto, vocês utilizam a resolução para entenderem melhor o como poderia ser feito. Veja que há muitos modos de resolver, apresentaremos apenas um deles.

* Dicas: 'beside', 'legend', 'bty = 'n'

```{r echo=FALSE}
#1-) Fazer a divisão da tela: 
par(mfrow=c(1,2))

#2-) Criar o barplot, da maneira que já aprendemos: 
##Criar a tabela considerando as informacoes de Area e Genero 
nota_gen <-table(dados$Area, dados$Genero)

##Note o parâmetro beside (que estava nas dicas) 
barplot(t(nota_gen),beside = TRUE, col = c("wheat", "tomato2"), main = "Distribuição das
pessoas \n de acordo com área e nota do R", xlab = "Nota do R")
##Colocar a legenda no gráfico 
legend("topright", title = "Gênero", legend=c("F","M"), fill = c("wheat", "tomato2"), bty = "n", cex = 0.7)

#3-) Criar o dotchart #Criar a coluna atribuindo uma cor para cada área 
dados$color[dados$Area=="Exatas"] <- "darkblue"
dados$color[dados$Area=="Biologicas"] <- "darkgreen"
dados$color[dados$Area=="Humanas"] <- "orange"
dados$color[dados$Area=="Interdiciplinar"] <- "red"
dados$color[dados$Area=="Agrarias"] <- "black"

##Colocar os pesos em ordem: 
dados <- dados[order(dados$Peso),]

##Colocar o título, note que o '\n' está sendo usado para fazer a quebra de linha: 
dotchart(dados$Peso, labels = dados$Cidade, groups = as.factor(dados$Area),
         color = dados$color, font=2, main = "Peso de acordo com as cidades, \n agrupando por área",
         xlab = "Peso", pch = 7)

#4-) Manter novamente uma figura por gráfico 
par(mfrow=c(1,1))

```

Uma solução que utiliza tudo o que vocês aprenderam:

```{r eval=FALSE}
#1-) Fazer a divisão da tela: 
par(mfrow=c(1,2))

#2-) Criar o barplot, da maneira que já aprendemos: 
##Criar a tabela considerando as informacoes de Area e Genero 
nota_gen <-table(dados$Area, dados$Genero)

##Note o parâmetro beside (que estava nas dicas) 
barplot(t(nota_gen),beside = TRUE, col = c("wheat", "tomato2"), main = "Distribuição das
pessoas \n de acordo com área e nota do R", xlab = "Nota do R")
##Colocar a legenda no gráfico 
legend("topright", title = "Gênero", legend=c("F","M"), fill = c("wheat", "tomato2"), bty = "n", cex = 0.7)

#3-) Criar o dotchart #Criar a coluna atribuindo uma cor para cada área
dados$color[dados$Area=="Exatas"] <- "darkblue"
dados$color[dados$Area=="Biologicas"] <- "darkgreen"
dados$color[dados$Area=="Humanas"] <- "orange"
dados$color[dados$Area=="Interdiciplinar"] <- "red"
dados$color[dados$Area=="Agrarias"] <- "black"

##Colocar os pesos em ordem: 
dados <- dados[order(dados$Peso),]

##Colocar o título, note que o '\n' está sendo usado para fazer a quebra de linha: 
dotchart(dados$Peso, labels = dados$Cidade, groups = as.factor(dados$Area),
         color = dados$color, font=2, main = "Peso de acordo com as cidades, \n agrupando por área",
         xlab = "Peso", pch = 7)

#4-) Manter novamente uma figura por gráfico 
par(mfrow=c(1,1))

```

## Salvar gráficos

Os gráficos podem ser salvos através dos menus disponíveis no RStudio, ou através de funções que permitem salvar em formatos específicos. Algumas delas são: pdf(); png(); jpeg(); bitmap(). De maneira geral, o parâmetro primordial é fornecer o nome do arquivo que será gerado (contendo sua extensão). Após abrir a função gráfica, deve-se gerar o gráfico de interesse. Por fim, utiliza-se o comando dev.off() para que saída gráfica volte para o console.

```{r eval=FALSE}
png(filename = "grafico_pontos.png")
plot(x = dados$Peso, y= dados$Altura, 
     main = "Peso  x Altura", #Título principal 
     xlab = "Peso", #Eixo x
     ylab = "Altura", #Eixo y
     col = as.factor(dados$Genero),
     pch=10)
dev.off()

png(filename = "grafico_pontos.png", width = 1500, height = 1500, res= 300)
plot(x = dados$Peso, y= dados$Altura, 
     main = "Peso  x Altura", #Título principal 
     xlab = "Peso", #Eixo x
     ylab = "Altura", #Eixo y
     col = as.factor(dados$Genero),
     pch=10)
dev.off()
```

Agora, gere um gráfico e salve-o no formato de seu interesse. Em seguida, crie diversos gráficos dentro de uma mesma função gráfica e estude a saída. 

# Instalação e aplicações de pacotes

Existem diversos pacotes disponíveis para variadas aplicações. Utilizaremos o *ggplot2*, que está disponível no repositório oficial do R, o CRAN. Portanto para instalá-lo:

```{r eval=FALSE}
install.packages("ggplot2")
```

Depois disso é necessário recrutá-lo com:

```{r}
library("ggplot2")
```

O *ggplot2* é um pacote que permite a construção de gráficos estatísticos, suas funcionalidades vão muito além do que está disponível nos gráficos básicos do R. Vamos tentar fazer um exemplo? 

Primeiramente precisamos de um *data frame*, como o conjunto de dados que estamos usando as colunas para mapear as observações a serem dispostas no gráfico. Vamos criar um gráfico de dispersão com as variáveis *Peso* e *Altura*.

```{r}
ggplot(dados) +
  geom_point(aes(x=Peso, y=Altura))

```

Veja que o sinal '+' indica que estamos adicionando uma nova camada. O legal do pacote é que a customização dos aspectos visuais é bem intuitiva. Por exemplo, vamos colorir os pontos de acordo com a variável *Genero*.

```{r}
ggplot(dados) +
  geom_point(aes(x=Peso, y=Altura, colour=Genero))

```

Também podemos alterar o tamanho dos pontos:

```{r}
ggplot(dados) +
  geom_point(aes(x=Peso, y=Altura, color=Genero), size=12)

```

Veja que o parâmetro *size* permaneceu fora da função de mapeamento, *aes*. Lembre-se que o mapeamento precisa de variáveis com observações. Colocar o *size* apenas como parâmetro da *geom_point* é interessante porque vamos alterar o tamanho de todos os pontos do gráfico.

Que tal tentarmos fazer um boxplot utilizando como variável resposta o *ConhecimentoR* de acordo com a *Area*?

```{r echo=FALSE}
ggplot(dados) +
  geom_boxplot(aes(x=Area, y=ConhecimentoR))

```

Quer botar uma corzinha? Tenta adicionar o *fill* de acordo com a *Area*.

```{r echo=FALSE}
ggplot(dados) +
  geom_boxplot(aes(x=Area, y=ConhecimentoR, fill=Area))

```

Mas a legenda fica redundante com o eixo x, será que conseguimos suprimí-la? Tenta ver algo como *show.legend* na função *geom_boxplot*.

```{r echo=FALSE}
ggplot(dados) +
  geom_boxplot(aes(x=Area, y=ConhecimentoR, fill=Area), show.legend = FALSE)

```


<span style="color:red"> Paramos aqui na primeira parte da manhã de sábado (18.05) e seguimos para uma parte específica da sessão **Algumas Ferramentas de Análise de dados**, clique [aqui](#experimento-de-cafe) para ir até lá.</span>


## E nossa motivação? Dá para fazer um gráfico?

Mas é claro que sim!!! Vai ser um pouquinho mais complexo, mas a gente chega lá.

Precisaremos instalar três pacotes: i) **tm**, ii) **SnowballC** e iii) **wordcloud**.

```{r message=FALSE, warning=FALSE, eval=FALSE}
install.packages(c('tm', 'SnowballC', 'wordcloud'), dependencies = T)
```


```{r message=FALSE, warning=FALSE}
library('tm')
library('SnowballC')
library('wordcloud')
```

Vamos ter que criar um Corpus e depois convertê-lo para um documento. Em seguida, removeremos a pontuação e as *stopwords*.

```{r}
dataCorpus <- Corpus(VectorSource(dados$Motivacao))

dataCorpus <- tm_map(dataCorpus, content_transformer(tolower))

dataCorpus <- tm_map(dataCorpus, removePunctuation) 

dataCorpus <- tm_map(dataCorpus, removeWords, stopwords('pt')) 
```

Agora podemos construir nossa nuvem de palavras:

```{r}
wordcloud(dataCorpus,max.words=100,colors=c("#2553A4","#11A858"))
```

## Mapa

Agora utilizaremos as informações de suas cidades para mostrá-las em um mapa. Vamos ter que instalar alguns pacotes, mas o resultado vale a pena:


```{r message=FALSE, warning=FALSE, eval=TRUE}
# Carregar os pacotes
library("dplyr")
library("osmdata")
library("ggmap")
library("sf")
library("rnaturalearth")
library("rnaturalearthdata")
library("rgeos")

# Encontrar latitude e longitude das cidades
cidades <- data.frame(Long=NA, Lat=NA)
for(idx in 1:nrow(dados)){
  latLong <- getbb(paste0(dados$Cidade[idx]," ", "Brazil"))
  cidades[idx, ] <- rowMeans(latLong)
  
}

# Obter as fronteiras no mapa mundial
world <- ne_countries(scale = "medium", returnclass = "sf")

#Fazer o mapa 
ggplot(data = world) +
    geom_sf() +
  geom_point(data = cidades, 
             aes(x = Long, y = Lat, fill = "red"), 
             size = 2, shape = 21, show.legend = FALSE) +
      coord_sf(xlim = c(-74, -30), ylim = c(-35, 5), expand = FALSE)
```


# Família de funções `apply`

A família de funções `apply` também podem funcionar como um estrutura de repetição. Sua sintaxe é mais enxuta quando comparada com `for` ou `while` e pode facilitar a elaboração do código. 

Aqui vamos exemplificar o uso de algumas dessas funções.

## apply

A função `apply` é a base de todas as outras funções da família, portanto a compreensão do funcionamento desta é essencial para entender as demais. Se buscar no help da função, ele indicará que os argumentos da função consistem em: apply(X, MARGIN, FUN, ...). Sendo X o conjunto de dados em formato de array (incluindo matrix, que consiste num array de dimensão 2), MARGIN será 1 se a ação deverá ser aplicada à linhas, 2 se for aplicada a colunas e c(1,2) se for aplicada a ambas; FUN é a função que indica ação.

Num simples exemplo temos a matrix:

```{r}
ex_mat <- matrix(seq(0,21,3), nrow = 2)
```

Se quisermos somar os elementos das colunas usamos:

```{r}
apply(ex_mat, 2, sum)
```

Se quisermos somar os elementos das linhas:

```{r}
apply(ex_mat, 1, sum)
```

Se fossemos utilizar o `for` para realizar essa tarefa:

```{r}

# Soma das colunas
for(i in 1:dim(ex_mat)[2]){
  print(sum(ex_mat[,i]))
}

# Soma das linhas
for(i in 1:dim(ex_mat)[1]){
  print(sum(ex_mat[i,]))
}
```

## lapply

Se diferencia do `apply` por poder receber outros tipos de objetos (mais utilizado com listas) e devolver o resultado  em uma lista.


```{r}
ex_list <- list(A=matrix(seq(0,21,3), nrow = 2), 
                B=matrix(seq(0,14,2), nrow = 2), 
                C= matrix(seq(0,39,5), nrow = 2))
str(ex_list)
```

Para selecionar a segunda coluna de todas as matrizes

```{r}
lapply(ex_list, "[", 2)
```

## sapply

A função `sapply` funciona como o `lapply` a diferença é que ele retorna apenas um valor por componente da lista e os deposita em um vetor de resposta. Como no exemplo:

```{r}
sapply(ex_list, "[",1,3)
```

## tapply

Esta função é um pouco diferente das demais, ela exige que exista alguma variável categórica (fator) para aplicar ação separadamente conforme suas categorias (levels). Por isso, normalmente é aplicada a data.frames.

Vamos utilizar nosso conjunto de dados:

```{r}
str(dados)
dados$Area <- as.factor(dados$Area)
tapply(dados$ConhecimentoR, dados$Area, mean)

```

Saiba mais sobre essa família de funções no [link](https://www.r-bloggers.com/r-tutorial-on-the-apply-family-of-functions/)

Observe que nas funções `apply` podemos trocar as funções prontas do *r base* por funções personalizadas. 

> Faça o exercício [**extra**](exercicios.html)

# Algumas ferramentas básicas de análise de dados

Claramente a análise de dados é algo muito específico de cada conjunto de dados e interesses. Vamos aqui mostrar alguns recursos básicos como análise de variância, regressão e teste de médias.

Algumas avaliações descritivas podem ser feitas pelo uso do `tapply` e de gráficos. A função `summary` também da informações gerais do conjunto. É possível usá-la em conjunto com o `tapply`.

```{r}
str(dados)
# Certifique-se que esta lidando com variável categórica (fator)
dados$Genero <- as.factor(dados$Genero)

tapply(dados$Altura, dados$Genero, summary)
tapply(dados$Peso, dados$Genero, summary)

```

Podemos falar que os pesos são significativamente diferentes entre homens e mulheres?

```{r}
mod1 <- lm(Peso ~ Genero, data = dados)
summary(mod1)

# ou o equivalente

mod1 <- aov(Peso ~ Genero, data = dados)
summary(mod1)

```

A diferença entre as duas funções é apenas na forma como é apresentada os resultados. O p-valor nos indica se podemos considerar diferenças do peso conforme o gênero.

Podemos obter mais informações sobre o modelo ajustado observando os gráficos:

```{r, eval=FALSE}
plot(mod1)
```

Vamos utilizar outro conjunto de dados para realizarmos mais avaliações utilizando a função `lm`. Acesse o conjunto [clima_lond](clima_lond.RData):

```{r}
load("clima_lond.RData")
```

Para obter os dados de precipitação da cidade de Londrina no primeiro semestre de 2017. Vamos utilizar as funções `tapply` e
`lm` para avaliar os dados.

```{r}
# Verificando se as variáveis categórias estão como fatores
str(clima_lond)

clima_lond$dia <- as.factor(clima_lond$dia)

# A precipitação nesse caso é uma variável contínua, nao categórica, para transformá-la use:

clima_lond$prec.mm <- as.numeric(as.character(clima_lond$prec.mm))

# Já com o tapply podemos ver as diferenças

tapply(clima_lond$prec.mm, clima_lond$Mes, summary)
```

Repare que os levels aparecem em ordem alfabética e não conforme o tempo, alteramos isso com:

```{r}
levels(clima_lond$Mes)

pos <- match(c("Janeiro", "Fevereiro", "Marco", "Abril", "Maio", "Junho"), levels(clima_lond$Mes))
pos

clima_lond$Mes = factor(clima_lond$Mes,
                       levels(clima_lond$Mes)[pos])

# Refazendo
tapply(clima_lond$prec.mm, clima_lond$Mes, summary)

```

Podemos também avaliar fazendo alguns gráficos:

```{r}
plot(prec.mm~Mes, data = clima_lond, main="Médias",
     xlab = "Meses do ano de 2017",
     ylab = "Precipitação em mm")
```

```{r}
barplot(tapply(clima_lond$prec.mm, clima_lond$Mes, sum), 
        main="Total Mensal",
        xlab = "Meses do ano de 2017",
        ylab = "Precipitação em mm")
```

Vamos então realizar um análise de variância para medir diferenças entre os meses.

```{r}
mod <- lm(prec.mm ~ Mes, data = clima_lond)
summary(mod)
```

Entre os dias:

```{r}
mod <- lm(prec.mm ~ dia, data = clima_lond)
summary(mod)
```

Podemos também fazer um teste de médias para diferenciar a precipitação ao decorrer dos meses. Aqui utilizaremos o método de Tukey:

```{r}
modaov <- aov(prec.mm ~ Mes, data = clima_lond)
tukey.test <- TukeyHSD(x=modaov, 'Mes', conf.level=0.95)
tukey.test
```


## Experimento de café

Agora, vamos trabalhar com outro conjunto de dados, contendo informações de um experimento de café. Acesse aqui:

* Arquivo [cafe.txt](https://GENt-esalq.github.io/cursoR/cafe.txt)

O experimento trata-se de dados em blocos completos casualizados de 10 progênies de café. Nele contém uma coluna rep para especificar a qual repetição o dado se refere, outra para qual indivíduo da progênie (prog) e outra para indicar em qual colheita o dado foi retirado (colheita).

```{r}
data <- read.table("cafe.txt", h = TRUE, sep = "\t", dec = ",")
str(data)
```

Não esqueça que é necessário que o arquivo esteja no seu ambiente de trabalho ou que você especifique o caminho completo para que o R o encontre.

Para essa análise de dados, nossa variável resposta é a produção (prod), a repetição (rep), a progênie (prog) e a colheita serão fatores no nosso modelo, identificados por seus níveis.

```{r}
# Transformar em fator
data$rep <- as.factor(data$rep)
data$prog <- as.factor(data$prog)
data$colheita <- as.factor(data$colheita)
str(data)

# Outra opção
data <- transform(data, rep = factor(rep), prog = factor(prog), colheita = factor(colheita))
str(data)
```

Vamos primeiro análisar somente os dados referentes à primeira colheira. Podemos fazer um subset somente com esses dados.

```{r}
# Indexar primeita colheita
Colheita_1 <- subset(data, colheita == 1)
str(Colheita_1)
```


Repare que, ao fazer o subset, o conjunto de dados ainda mantém os três níveis do fator colheira, embora agora só tenhamos um. Isso pode ser um problema para a nossa análise, vamos remover os níveis excedentes com:

```{r}
# Droplevels
Colheita_1 <- droplevels(subset(data, colheita == 1))
str(Colheita_1)
```


Agora podemos rodar nosso modelo de análise de variância.

```{r}
# Modelo
Modelo1 <- aov(prod ~ rep + prog,
               contrasts = list(prog = "contr.sum"), 
               data = Colheita_1)
anova(Modelo1)
```

Essa análise variância exige alguns pressupostos, podemos verificar eles nos nossos dados usando:

```{r}
####################################################
###verificar Pressupostos da análise de variância###
####################################################
names(Modelo1)
Modelo1_residuals <- Modelo1$residuals #armazenando os erros ou resíduos

# teste de Normalidade DOS ERROS##
#---------------------------------#
shapiro.test (Modelo1_residuals) # Hipótese de Nulidade
# a hipótese de que os erros são normais, nesse caso, como o p-value = 0.24
# ou seja, >0.05 ou 0.01 ou qualquer alfa adotado, não se rejeita a hipotese de normalidade 
```

Agora, vamos precisar de funções contidas nos scripts `DIAGNOSTICS.R` e `"outliers.R"`. Acesse eles em:

* [DIAGNOSTICS.R](https://GENt-esalq.github.io/cursoR/DIAGNOSTICS.R)
* [outliers.R](https://GENt-esalq.github.io/cursoR/outliers.R)

```{r, eval=TRUE}
# Funções
source("DIAGNOSTICS.R")
source("outliers.R")


#Verificar pressupostos de análises
diagnostics(Modelo1$residuals, Modelo1$fitted.values)
```

As vezes outliers podem ser difíceis de identificarmos, aqui esta uma função (detalhes sobre a identificação e remoção de outliers estão disponíveis no artigo Bernal-Vasquez, AM., Utz, HF. & Piepho, HP. Theor Appl Genet-2016) que pode fazer isso:

```{r, eval=TRUE, message=FALSE, warning=FALSE}
# Verificar outlier
outlier(Modelo1$residuals, alpha=0.05)
```

Guardando o valor do quadrado médio:

```{r, eval=TRUE}
QME <- anova(Modelo1)["Residuals", "Mean Sq"]
QME
```

E a média da primeira colheita da nossa variavel resposta (produção):

```{r, eval=TRUE}
med <- mean(Colheita_1$prod, na.rm = TRUE)
med
```

Com eles podemos calcular o coeficiente de variação (CV):

```{r, eval=TRUE}
CVe <- (sqrt(QME)/med)*100
CVe
```

> Calcule o CVe e QME para a colheita 2

> Crie uma função calcular o CVe

Possibilidade de respostas:

```{r, eval=TRUE}
CV_E <- function(anova, med){
  QME <- anova(anova)["Residuals", "Mean Sq"]
  CVe <- (sqrt(QME)/med)*100
  
  return(CVe)
}

## 
CV_E(anova = Modelo1, med = med)
```

Podemos também calcular a herdabilidade da característica produção:

```{r, eval=TRUE}
n_rep <- nlevels(Colheita_1$rep)
VG <- (anova(Modelo1)["prog", "Mean Sq"]- QME)/n_rep
VE <- QME
H_2 <- VG/ (VG + VE)
H_2
```


> Crie uma função para estimar a herdabilidade 


Agora faremos um teste de comparações múltiplas utilizando a análise de variância feita no pacote `ExpDes`.

```{r,  message=FALSE, warning=FALSE}
#install.packages("ExpDes")
library(ExpDes)

# Teste de Tukey
rbd(Colheita_1$prog, Colheita_1$rep, Colheita_1$prod, mcomp = "tukey", sigT = 0.05, sigF = 0.05)

# Teste de agrupamento de Scot- Knott
rbd(Colheita_1$prog, Colheita_1$rep, Colheita_1$prod, mcomp = "sk", sigT = 0.05, sigF = 0.05)

```

Agora vamos apresentar outras opções para analisarmos cada colheita individualmente. 

```{r,  message=FALSE, warning=FALSE}
# função by é similar ao subset
by(data, data$colheita, function (x) anova(aov(prod ~ prog + rep, data= x))) 
#verificar os graus de liberdade, cuidado para que sejam utilizados de fato os dados de apenas 1 colheita


#outra opção selecionando apenas a parte da dataframe onde colheita igual a "2"
anova(aov(data$prod ~ data$prog + data$rep, data = data[data$colheita==2,]))

# mais uma opção com o uso da família apply
indiv <- lapply(split(data, data$colheita), aov, formula = prod ~ rep + prog)
lapply(indiv, summary)
```

Agora, com o pacote `agricolae` elaboraremos o sorteio de um experimento também de blocos completos casualizados.

```{r,  message=FALSE, warning=FALSE}
############################
#SORTEIO DE EXPERIMENTOS####
############################

#install.packages("agricolae")
library(agricolae)
trt <- c("0","1","2","5","10","20","50","100","Dina")
rcbd <- design.rcbd(trt, 6, serie = 1, seed = 1, "default") # seed = 1
rcbd # Planilha de campo
```

Podemos exportar e salvar nosso sorteio com:

```{r}
write.table(rcbd,"SORTEIO.txt", row.names=FALSE, sep="\t")
file.show("SORTEIO.txt")
write.csv(rcbd,"SORTEIO.csv",row.names=F)
```

<span style="color:red"> Paramos aqui no sábado (18.05),terceiro e último dia do treinamento.</span>


# Pratique gerando relatórios no RStudio
 
 Utilize o R no seu dia-a-dia para ir praticando a linguagem. Além das recomendações contidas na [primeira apresentação](), recomendamos também dar uma olhada em como gerar documentos em pdf e html usando a Markdown. Utilizamos essa metodologia para gerar este tutorial e outras apresentações do curso. Pode ser muito prático no dia-a-dia!
 
Para utilizar, será necessário a instalação de outros pacotes. Um deles é o próprio `rmarkdown`:

```{r, eval=FALSE}
install.packages("rmarkdown")
```

```{r}
library(rmarkdown)
```
 
Agora crie um arquivo .Rmd utilizando as facilidades do RStudio, clique no ícone com símbolo `+` no canto superior esquerdo. Escolha o opção `R Markdown`. Dê um título ao seu arquivo e escolha a opção `html`. Ao fazer isso, o RStudio já coloca um template inicial, ja com um cabeçalho:

```
---
title: "Teste"
author: "Eu"
date: "June 5, 2018"
output: html_document
---

```

Este é o mais simples possível, você pode otimizá-lo de diversas maneiras. Saiba mais [aqui](https://rmarkdown.rstudio.com/html_document_format.html).

O template inicial também traz alguns exemplos de sintaxe do markdown. Observe que utilizando `#` para títulos de sessões, `##` para um nível inferior (subtitulos) e assim por diante. Palavras em negrito são escritas em meia a dois `*` e existem diversas outras especificações para essa sintaxe. Veja mais sobre ela [aqui](https://www.markdownguide.org/basic-syntax).

Para compilar o código, basta clicar em `Knit`. Ele irá pedir para que o arquivo .Rmd seja salvo com algum nome em algum lugar.

O markdown também é capaz de entender diretamente a linguagem html, também a css e latex. Para essa última, o latex precisa estar instalado e todas suas dependências.

Existem alguns pacotes que fornecem templates mais robustos para produção de htmls. Para esse tutorial utilizando o pacote `rmdformats` e personalizamos suas cores. Experimente:

```{r, eval=FALSE}
install.packages("rmdformats")
```

Agora faça o mesmo procedimento, clique no `+`, escolha `R Markdown` e, antes de escolher um título, mude para `From Template`, escolha o `HTML readthedown template`. Copie e cole o seguinte texto e aperte `Knit`.

```
# Teste1

Isso aqui é um teste só para dar uma olhada no template

## Testinho

Subsessão

* Item

**negrito**

*itálico*

fiz um [link](https://GENt-esalq.github.io/)!

```


Saiba mais no tutorial sobre isso no R-bloggers, que acreditamos ser um bom começo! Acesse [aqui](https://www.r-bloggers.com/how-to-create-reports-with-r-markdown-in-rstudio/).

---

Caso tenha sugestões para aprimoramento desse material, enviar e-mail para `gent.esalq@gmail.com`.

Acesse também outros materiais em português produzidos por Cristiane Taniguti, Fernando Correr e Rodrigo Amadeu [aqui](http://cristianetaniguti.github.io/Workshop_genetica_esalq/).

Este material foi produzido por alunos do programa de pós-graduação em Genética e Melhoramento de Plantas. Cristiane Taniguti, Fernando Correr e Kaio Olimpio ministraram o Treinamento. Também contamos com os monitores: Letícia de Castro Lara, Getúlio Caixeta, Gabriel Gesteira, Rafael Yassue, Fernando Espolador, Júlia Morosini, Guilherme Hokasa, Vitor Mello, Ana Letycia Basso, Jessica Ferrarezi e Jéssica Nogueira de Souza.

Também recomendamos materiais em inglês [aqui](https://GENt-esalq.github.io/cursoR/english_tutorials.html).
